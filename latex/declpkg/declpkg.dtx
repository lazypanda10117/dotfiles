% \iffalse meta-comment
%<*internal>
\iffalse
%</internal>
%<*readme>
declpkg - Including packages with dependencies
==============================================

The `declpkg` package includes packages with user provided order.

Installation
------------

The package is supplied in `.dtx` format.
To unpack the `.dtx`, running `tex` will extract the package and
`latex` will extract it and also typeset the documentation.

The package requires LaTeX3 support.
%</readme>
%<*internal>
\fi
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
%</internal>
%<*install>
\input l3docstrip.tex
\keepsilent
\askforoverwritefalse
\preamble
---------------------------------------------------------------
declpkg --- Including packages with dependencies
Maintained by Ting Wei Liu
E-mail: tingwei890@gmail.com
---------------------------------------------------------------

\endpreamble
\nopostamble
\usedir{tex/latex/declpkg}
\generate{
  \file{\jobname.sty}{\from{\jobname.dtx}{package}}
}
%</install>
%<install>\endbatchfile
%<*internal>
\nopreamble\nopostamble
\usedir{source/latex/declpkg}
\generate{
  \file{\jobname.ins}{\from{\jobname.dtx}{install}}
}
\nopreamble\nopostamble
\usedir{doc/latex/declpkg}
\generate{
  \file{README.md}{\from{\jobname.dtx}{readme}}
}
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%</internal>
%<*driver>
\documentclass[full]{l3doc}
\usepackage{declpkg}
\usepackage[final]{listings}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
%\GetFileInfo{\jobname.sty}
%
% \title{^^A
%   \pkg{declpkg} --- Including packages with dependencies
%     \thanks{^^A
%       This file describes version \fileversion, last revised \filedate.^^A
%     }^^A
% }
% \author{^^A
%   Ting Wei Liu\thanks{E-mail: tingwei890@gmail.com}^^A
% }
% \date{Released \filedate}
%
% \changes{v1.0}{2020-05-08}{First public release}
% \changes{v1.1}{2020-05-10}{Add pre-hooks}
%
% \maketitle
%
% \begin{abstract}
%   The \pkg{declpkg} package includes packages with user provided order.
% \end{abstract}
%
% \tableofcontents
% \clearpage
%
% \StopEventually{^^A
% \clearpage
% \PrintChanges
% \clearpage
% \PrintIndex
% }
%
% \begin{documentation}
%
%\section{Installation}
%\label{sec:installation}
%
% The package is supplied in \file{dtx} format.
% To unpack the \file{dtx}, running \texttt{tex \jobname.dtx} will extract the package and
% \texttt{latex \jobname.dtx} will extract it and also typeset the documentation.
%
% The package requires LaTeX3 support.
%
%
%\section{Documentation}
%\label{sec:documentation}
%
%   \begin{function}{\declpkg}
%     \begin{syntax}
%       \cs{declpkg} \oarg{options} \marg{package}
%       \cs{declpkg} \oarg{options} \marg{package} [\meta{prereqs}] <\meta{antireqs}>
%       \cs{declpkg} \oarg{options} \marg{package} (\meta{load befores}) (\meta{load after})
%       \cs{declpkg} \meta{*} \oarg{options} \marg{package} [\meta{prereqs}] [\meta{postreqs}] [\meta{coreqs}] <\meta{antireqs}> (\meta{load befores}) (\meta{load after})
%     \end{syntax}
%
%     \cs{declpkg} declares a package that will be included.
%     The \texttt{\meta{*}} variant disables the package.
%   \end{function}
%
%   \begin{function}{\IncludePackages}
%     Calling \cs{IncludePackages} will include all packages.
%     There is no harm in calling this multiple times.
%
% \begin{verbatim}
% \usepackage{declpkg}
% % Some declarations ...
%
% \IncludePackages
% \begin{document}
% \end{verbatim}
%   \end{function}
%
%   \begin{function}{\AfterAll, \BeforeAll}
%     \begin{syntax}
%       \cs{AfterAll} \marg{packages} \marg{code}
%       \cs{BeforeAll} \marg{packages} \marg{code}
%     \end{syntax}
%
%     \cs{AfterAll} and \cs{BeforeAll} hook some \marg{code} to run after/before all \marg{packages} have loaded.
%   \end{function}
%
%   \begin{function}{\AfterAny, \BeforeAny}
%     \begin{syntax}
%       \cs{AfterAny} \marg{packages} \marg{code}
%       \cs{BeforeAny} \marg{packages} \marg{code}
%     \end{syntax}
%
%     \cs{AfterAny} and \cs{BeforeAny} hook some \marg{code} to run after/before one of \marg{packages} has loaded.
%     This code is only ran once.
%   \end{function}
%
%   \begin{function}{\AddOptionsToPackage, \RemoveOptionsToPackage}
%     \begin{syntax}
%       \cs{AddOptionsToPackage} \marg{options} \marg{packages}
%       \cs{RemoveOptionsToPackage} \marg{options} \marg{packages}
%     \end{syntax}
%
%     Add or remove options from a package.
%     Remove takes priority over add.
%   \end{function}
%
% \end{documentation}
%
% \clearpage
%
% \begin{implementation}
%
%   \section{Implementation}
%
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
%    \begin{macrocode}
%<@@=declpkg>
%    \end{macrocode}
%
% Version data information.
%    \begin{macrocode}
\RequirePackage{expl3}
\ProvidesExplPackage{declpkg}{2020-05-10}{1.1}{Including packages with dependencies}
%    \end{macrocode}
%
% Required packages.
%    \begin{macrocode}
\RequirePackage { xparse }
%    \end{macrocode}
%
%
%\subsection{Lambdas}
%\label{sec:lambdas}
%
% \begin{variable}{\g_@@_lambda_counter_int}
%   A counter for lambda functions declared.
%    \begin{macrocode}
\int_new:N \g_@@_lambda_counter_int
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_@@_last_lambda_tl}
%   The name of the last lambda function.
%    \begin{macrocode}
\tl_new:N \g_@@_last_lambda_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\@@_lambda:n}
%   Create a lambda function and store its name in \cs{g_@@_last_lambda_tl}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_lambda:n
{
  \tl_gset:Nx \g_@@_last_lambda_tl
  {
    c_@@_lambda_
    \int_use:N \g_@@_lambda_counter_int
    _tl
  }

  \tl_const:cn { \tl_use:N \g_@@_last_lambda_tl } { #1 }
  \int_gincr:N \g_@@_lambda_counter_int
}
\cs_generate_variant:Nn \@@_lambda:n { x }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_transient_lambda:n, \@@_transient_lambda:nn}
%   Create a lambda function that can only run once and store its name in \cs{g_@@_last_lambda_tl}
%   The two argument version takes a transiency variable and the code.
%    \begin{macrocode}
\cs_new:Nn \@@_transient_lambda:Nn
{
  \@@_lambda:n
  {
    \bool_if:NF #1
    {
      \bool_gset_true:N #1
      #2
    }
  }
}
\cs_generate_variant:Nn \@@_transient_lambda:Nn { cn, Nx, cx }

\cs_new:Nn \@@_transient_lambda:n
{
  \group_begin:
  \tl_set:Nn \l_tmpa_tl
  {
    g_@@_lambda_
    \int_use:N \g_@@_lambda_counter_int
    _bool
  }
  \bool_new:c { \tl_use:N \l_tmpa_tl }

  \@@_transient_lambda:cn { \tl_use:N \l_tmpa_tl } { #1 }
  \group_end:
}
\cs_generate_variant:Nn \@@_transient_lambda:n { x }
%    \end{macrocode}
% \end{macro}
%
%
%\subsection{Internal helpers}
%\label{sec:internal-helpers}
%
% \begin{macro}{\@@_new_var:Nn}
%   Create a new variable of a certain type.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_new_var:Nn
{
  \cs:w #2 _if_exist:NF \cs_end: #1
  {
    \cs:w #2 _new:N \cs_end: #1
  }
}
\cs_generate_variant:Nn \@@_new_var:Nn { cn }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_seq_ginsert:Nn}
% \begin{macro}[TF]{\@@_seq_ginsert:Nn}
%   Insert an element uniquely into a global seq.
%   True if successfully inserted, False otherwise.
%    \begin{macrocode}
\prg_new_protected_conditional:Nnn \@@_seq_ginsert:Nn { T, F, TF }
{
  \@@_new_var:Nn #1 { seq }
  \seq_if_in:NnTF #1 { #2 }
  {
    \prg_return_false:
  } {
    \seq_gput_right:Nn #1 { #2 }
    \prg_return_true:
  }
}
\prg_generate_conditional_variant:Nnn \@@_seq_ginsert:Nn
{ NV, Nv, No, Nx, cn, cV, cv, co, cx } { T, F, TF }

\cs_new:Nn \@@_seq_ginsert:Nn
{
  \@@_seq_ginsert:NnTF #1 { #2 } {} {}
}
\cs_generate_variant:Nn \@@_seq_ginsert:Nn { NV, Nv, No, Nx, cn, cV, cv, co, cx }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \subsection{Variables and constants}
% \label{sec:variables-constants}
%
% \begin{variable}{\g_@@_tmpa_tl, \g_@@_tmpb_tl, \l_@@_tmpa_tl, \l_@@_tmpa_clist}
%   Temp variables.
%    \begin{macrocode}
\tl_new:N \g_@@_tmpa_tl
\tl_new:N \g_@@_tmpb_tl
\tl_new:N \l_@@_tmpa_tl
\clist_new:N \l_@@_tmpa_clist
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_@@_packages_seq}
%   A list of packages declared with \pkg{declpkg}.
%    \begin{macrocode}
\seq_new:N \g_@@_packages_seq
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_@@_should_load_queue_seq, \g_@@_should_load_seq, \g_@@_should_not_load_seq}
%   Lists of packages that should and should not be loaded.
%    \begin{macrocode}
\seq_new:N \g_@@_should_load_queue_seq
\seq_new:N \g_@@_should_load_seq
\seq_new:N \g_@@_should_not_load_seq
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_@@_loaded_seq, \g_@@_to_load_seq}
%   Lists of packages that are loaded or queued to be loaded.
%    \begin{macrocode}
\seq_new:N \g_@@_loaded_seq
\seq_new:N \g_@@_to_load_seq
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_@@_<pkg>_add_options_seq, \g_@@_<pkg>_remove_options_seq}
%   List of options that should be added or removed for a package.
%   Removed takes priority over added.
% \end{variable}
%
% \begin{variable}{\g_@@_<pkg>_load_after_seq, \g_@@_<pkg>_load_before_seq}
%   List of packages that if loaded, should be done before or after a package.
% \end{variable}
%
% \begin{variable}{\g_@@_<pkg>_coreq_seq, \g_@@_<pkg>_antireq_seq}
%   List of packages that should be loaded or not with a package.
% \end{variable}
%
% \begin{variable}{\g_@@_<pkg>_pre_hook_seq, \g_@@_<pkg>_post_hook_seq}
%   List of macros that should be run before/after loading a package.
% \end{variable}
%
% \begin{variable}{\g_@@_<pkg>_load_reason_seq, \g_@@_<pkg>_not_load_reason_seq}
%   List of reasons as to why a package should be loaded or not.
% \end{variable}
%
% \begin{variable}{\g_@@_<pkg>_preorder_graph_children_seq}
%   List of packages that should be loaded before a package.
% \end{variable}
%
% \begin{variable}{\g_@@_<pkg>_to_load_parent_tl}
%   The direct parent that loaded a package.
% \end{variable}
%
%
%\subsection{Errors}
%\label{sec:errors}
%
% \begin{macro}{\@@_multiple_declare_error:n}
%   If a package is declared more than once.
%    \begin{macrocode}
\cs_new:Nn \@@_multiple_declare_error:n
{
  \PackageError {declpkg}
  {
    Multiple~declare, \MessageBreak
    packages~should~only~be~declared~once
  } {
    Package~ #1 ~is~declared~more~than~once.
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_should_and_should_not_error:n}
%   If a package, both, should be and should not be included.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_should_and_should_not_error:n
{
  \PackageError {declpkg}
  {
    Package~conflict, \MessageBreak
    package~ #1 ~is~set~to~be~included~and~not~included
  } {
    Package~ #1 ~should~be~included
    \MessageBreak \space \space
    \seq_use:cnnn { g_@@_ #1 _load_reason_seq }
    { ~and \MessageBreak \space \space }
    { , \MessageBreak \space \space }
    { ,~and \MessageBreak \space \space }
    ,\MessageBreak
    but~should~not~be~included
    \MessageBreak \space \space
    \seq_use:cnnn { g_@@_ #1 _not_load_reason_seq }
    { ~and \MessageBreak \space \space }
    { , \MessageBreak \space \space }
    { ,~and \MessageBreak \space \space }
    .
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_late_pre_hook_error:nn}
%    \begin{macrocode}
\cs_new:Nn \@@_late_pre_hook_error:nn
{
  \cs_show:c { #2 }
  \str_set:Nx \l_tmpa_str { \cs_to_str:N \cs:w #2 \cs_end: }
  \str_show:N \l_tmpa_str
  \PackageError { declpkg }
  {
    Pre-hook~defined~too~late, \MessageBreak
    pre-hooks~must~be~defined~before~packages~have~loaded
  } {
    Pre-hook~ #2 ~ is~defined~after~package~ #1 ~has~loaded.
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_dag_error:n}
%   If the dependency tree is not a DAG.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_dag_error:n
{
  \tl_gset:Nn \g_tmpa_tl { #1 }
  \tl_gset:Nn \g_tmpb_tl { #1 }
  \seq_gclear:N \g_tmpa_seq

  \bool_do_until:nn { \tl_if_eq_p:NN \g_tmpa_tl \g_tmpb_tl }
  {
    \seq_gput_left:NV \g_tmpa_seq \g_tmpb_tl

    \group_begin:
    \tl_set_eq:Nc \l_tmpa_tl
    {
      g_@@_
      \tl_use:N \g_tmpb_tl
      _to_load_parent_tl
    }
    \tl_gset_eq:NN \g_tmpb_tl \l_tmpa_tl
    \group_end:
  }

  \seq_gput_left:NV \g_tmpa_seq \g_tmpa_tl

  \PackageError { declpkg }
  {
    The~dependency~tree~is~not~a~DAG, \MessageBreak
    including~package~ #1 ~created~a~cycle
  } {
    The~cycle~is
    \MessageBreak \space \space
    \seq_use:Nn \g_tmpa_seq { ~->~ }
  }
}
%    \end{macrocode}
% \end{macro}
%
%
%\subsection{Internal interfaces}
%\label{sec:internal-interfaces}
%
% \begin{macro}{\@@_add_option:nn, \@@_remove_option:nn}
%   Add or remove an option from a package.
%    \begin{macrocode}
\cs_new:Nn \@@_add_option:nn
{
  \@@_seq_ginsert:cn { g_@@_ #1 _add_options_seq } { #2 }
}

\cs_new:Nn \@@_remove_option:nn
{
  \@@_seq_ginsert:cn { g_@@_ #1 _remove_options_seq } { #2 }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_load_after:nn, \@@_load_before:nn}
%   Introduce a precedence or posteriority relation between two packages.
%   \meta{package2} loads after/before \meta{package1}
%    \begin{macrocode}
\cs_new:Nn \@@_load_before:nn
{
  \@@_seq_ginsert:cn { g_@@_ #1 _load_before_seq } { #2 }
}

\cs_new:Nn \@@_load_after:nn
{
  \@@_seq_ginsert:cn { g_@@_ #1 _load_after_seq } { #2 }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_add_coreq:nn, \@@_add_prereq:nn, \@@_add_postreq:nn, \@@_add_antireq:nn}
%   Introduce a dependency or a conflict relation between two packages.
%    \begin{macrocode}
\cs_new:Nn \@@_add_coreq:nn
{
  \@@_seq_ginsert:cn { g_@@_ #1 _coreq_seq } { #2 }
}

\cs_new_protected:Nn \@@_add_prereq:nn
{
  \@@_add_coreq:nn { #1 } { #2 }
  \@@_load_before:nn { #1 } { #2 }
}

\cs_new_protected:Nn \@@_add_postreq:nn
{
  \@@_add_coreq:nn { #1 } { #2 }
  \@@_load_after:nn { #1 } { #2 }
}

\cs_new:Nn \@@_add_antireq:nn
{
  \@@_seq_ginsert:cn { g_@@_ #1 _antireq_seq } { #2 }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_should_load:nn, \@@_should_not_load:nn}
%   Indicate if a package should be loaded or not with a reason.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_should_load:nn
{
  \group_begin:
  \tl_set:Nn \l_tmpa_tl { #2 }
  \tl_if_blank:VF \l_tmpa_tl
  {
    \@@_seq_ginsert:cV { g_@@_ #1 _load_reason_seq } \l_tmpa_tl
  }
  \group_end:

  % error on conflict
  \seq_if_in:NnT \g_@@_should_not_load_seq { #1 }
  {
    \@@_should_and_should_not_error:n { #1 }
  }

  \seq_if_in:NnF \g_@@_should_load_seq { #1 }
  {
    \@@_seq_ginsert:Nn \g_@@_should_load_queue_seq { #1 }
  }
}

\cs_new_protected:Nn \@@_should_not_load:nn
{
  \group_begin:
  \tl_set:Nn \l_tmpa_tl { #2 }
  \tl_if_blank:VF \l_tmpa_tl
  {
    \@@_seq_ginsert:cV { g_@@_ #1 _not_load_reason_seq } \l_tmpa_tl
  }
  \group_end:

  % error on conflict
  \group_begin:
  \seq_concat:NNN \l_tmpa_seq \g_@@_should_load_seq \g_@@_should_load_queue_seq
  \seq_if_in:NnT \l_tmpa_seq { #1 }
  {
    \@@_should_and_should_not_error:n { #1 }
  }
  \group_end:

  \@@_seq_ginsert:Nn \g_@@_should_not_load_seq { #1 }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_add_pre_hook:nn, \@@_add_post_hook:nn}
%   Add hooks to a package that will be ran before/after a package is loaded.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_add_pre_hook:nn
{
  \seq_if_in:NnTF \g_@@_loaded_seq { #1 }
  {
    \@@_late_pre_hook_error:nn { #1 } { #2 }
  } {
    \seq_if_in:NnTF \g_@@_should_load_seq { #1 }
    {
      \tl_use:c { #2 }
    } {
      \@@_seq_ginsert:cn { g_@@_ #1 _pre_hook_seq } { #2 }
    }
  }
}
\cs_generate_variant:Nn \@@_add_pre_hook:nn { nV, nv, nx, Vn, VV, Vv, Vx, vn, vV, vv, vx }

\cs_new_protected:Nn \@@_add_post_hook:nn
{
  \seq_if_in:NnTF \g_@@_loaded_seq { #1 }
  {
    \tl_use:c { #2 }
  } {
    \@@_seq_ginsert:cn { g_@@_ #1 _post_hook_seq } { #2 }
  }
}
\cs_generate_variant:Nn \@@_add_post_hook:nn { nV, nv, nx, Vn, VV, Vv, Vx, vn, vV, vv, vx }
%    \end{macrocode}
% \end{macro}
%
%
%\subsection{Internals}
%\label{sec:internals}
%
% \begin{macro}{\@@_prep_load:n}
%   Move a package to \texttt{should_load_seq}, run its pre hooks, and add the
%   necessary coreq and antireq.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_prep_load:n
{
  % add to should load
  \@@_seq_ginsert:Nn \g_@@_should_load_seq { #1 }

  % run pre hooks
  \tl_gset:Nn \g_@@_tmpa_tl { g_@@_ #1 _pre_hook_seq }
  \seq_if_exist:cT { \tl_use:N \g_@@_tmpa_tl }
  {
    \seq_map_inline:cn { \tl_use:N \g_@@_tmpa_tl }
    {
      \tl_use:c { ##1 }
    }
  }

  % setup preorder graph
  \group_begin:
  \tl_set:Nn \l_tmpa_tl { g_@@_ #1 _load_before_seq }
  \seq_if_exist:cT { \tl_use:N \l_tmpa_tl }
  {
    \seq_map_inline:cn { \tl_use:N \l_tmpa_tl }
    {
      \@@_seq_ginsert:cn { g_@@_ #1 _preorder_graph_children_seq } { ##1 }
    }
  }
  \group_end:

  \group_begin:
  \tl_set:Nn \l_tmpa_tl { g_@@_ #1 _load_after_seq }
  \seq_if_exist:cT { \tl_use:N \l_tmpa_tl }
  {
    \seq_map_inline:cn { \tl_use:N \l_tmpa_tl }
    {
      \@@_seq_ginsert:cn { g_@@_ ##1 _preorder_graph_children_seq } { #1 }
    }
  }
  \group_end:

  % load coreqs
  \group_begin:
  \tl_set:Nn \l_tmpa_tl { g_@@_ #1 _coreq_seq }
  \seq_if_exist:cT { \tl_use:N \l_tmpa_tl }
  {
    \seq_map_inline:cn { \tl_use:N \l_tmpa_tl }
    {
      \@@_should_load:nn { ##1 } { per~request~of~#1 }
    }
  }
  \group_end:

  % not load antireqs
  \group_begin:
  \tl_set:Nn \l_tmpa_tl { g_@@_ #1 _anticoreq_seq }
  \seq_if_exist:cT { \tl_use:N \l_tmpa_tl }
  {
    \seq_map_inline:cn { \tl_use:N \l_tmpa_tl }
    {
      \@@_should_not_load:nn { ##1 } { per~request~of~#1 }
    }
  }
  \group_end:
}
\cs_generate_variant:Nn \@@_prep_load:n { V, v, x }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_load:n}
%   Include a package and run its post hooks.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_load:n
{
  % require package with options
  \group_begin:
  \seq_clear:N \l_tmpa_seq
  \tl_set:Nn \l_tmpa_tl { g_@@_ #1 _add_options_seq }
  \seq_if_exist:cT { \tl_use:N \l_tmpa_tl }
  {
    \seq_set_eq:Nc \l_tmpa_seq { \tl_use:N \l_tmpa_tl }
    \seq_remove_duplicates:N \l_tmpa_seq

    \tl_set:Nn \l_tmpa_tl { g_@@_ #1 _remove_options_seq }
    \seq_if_exist:cT { \tl_use:N \l_tmpa_tl }
    {
      \seq_map_inline:cn { \tl_use:N \l_tmpa_tl }
      {
        \seq_remove_all:Nn \l_tmpa_seq { ##1 }
      }
    }
  }

  \seq_if_empty:NF \tl_tmpa_seq
  {
    \PassOptionsToPackage { \seq_use:Nn \l_tmpa_seq { , } } { #1 }
  }
  \group_end:
  \RequirePackage { #1 }

  % add to loaded
  \@@_seq_ginsert:Nn \g_@@_loaded_seq { #1 }

  % run post hooks
  \tl_gset:Nn \g_@@_tmpa_tl { g_@@_ #1 _post_hook_seq }
  \seq_if_exist:cT { \tl_use:N \g_@@_tmpa_tl }
  {
    \seq_map_inline:cn { \tl_use:N \g_@@_tmpa_tl }
    {
      \tl_use:c { ##1 }
    }
  }
}
\cs_generate_variant:Nn \@@_load:n { V }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_to_load:n, \@@_to_load:nn}
%   Loads a package while making sure all dependencies are loaded first.
%   The first arugment is \marg{package} and \marg{parent} is an optional extra parameter.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_to_load:n
{
  \@@_seq_ginsert:NnF \g_@@_to_load_seq { #1 }
  {
    \@@_dag_error:n { #1 }
  }

  \tl_gset:Nn \g_@@_tmpa_tl { g_@@_ #1 _preorder_graph_children_seq }
  \seq_if_exist:cT { \tl_use:N \g_@@_tmpa_tl }
  {
    \seq_map_inline:cn { \tl_use:N \g_@@_tmpa_tl }
    {
      \seq_if_in:NnF \g_@@_loaded_seq { ##1 }
      {
        \@@_to_load:nn { ##1 } { #1 }
      }
    }
  }

  \@@_load:n { #1 }
}

\cs_new_protected:Nn \@@_to_load:nn
{
  \group_begin:
  \tl_set:Nn \l_tmpa_tl { g_@@_ #1 _to_load_parent_tl }
  \@@_new_var:cn { \tl_use:N \l_tmpa_tl } { tl }
  \tl_gset:cn { \tl_use:N \l_tmpa_tl } { #2 }
  \group_end:

  \@@_to_load:n { #1 }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_include_packages:}
%    \begin{macrocode}
\cs_new:Nn \@@_include_packages:
{
  \bool_until_do:nn { \seq_if_empty_p:N \g_@@_should_load_queue_seq }
  {
    \group_begin:
    \seq_gpop_left:NN \g_@@_should_load_queue_seq \l_@@_tmpa_tl
    \tl_gset_eq:NN \g_@@_tmpa_tl \l_@@_tmpa_tl
    \group_end:

    \seq_if_in:NVF \g_@@_should_load_seq \g_@@_tmpa_tl
    {
      \@@_prep_load:V \g_@@_tmpa_tl
    }
  }

  \seq_map_inline:Nn \g_@@_should_load_seq
  {
    \seq_if_in:NnF \g_@@_to_load_seq { ##1 }
    {
      \@@_to_load:n { ##1 }
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
%
%\subsection{Public interfaces}
%\label{sec:public-interfaces}
%
% \begin{macro}{\declpkg}
%   The main command to declare a package.
%    \begin{macrocode}
\NewDocumentCommand \declpkg { s o m d[] d[] d[] d<> d() d() }
{
  \@@_seq_ginsert:NnF \g_@@_package_seq { #3 }
  {
    \@@_multiple_declare_error:n { #3 }
  }

  \IfBooleanTF { #1 }
  {
    \@@_should_not_load:nn { #3 } { per~user~request }
  } {
    \@@_should_load:nn { #3 } { per~user~request }
  }

  \IfValueT { #2 }
  {
    \group_begin:
    \clist_set:Nn \l_tmpa_clist { #2 }
    \clist_map_inline:Nn \l_tmpa_clist
    {
      \@@_add_option:nn { #3 } { ##1 }
    }
    \group_end:
  }

  \IfValueT { #4 }
  {
    \group_begin:
    \clist_set:Nn \l_tmpa_clist { #4 }
    \clist_map_inline:Nn \l_tmpa_clist
    {
      \@@_add_prereq:nn { #3 } { ##1 }
    }
    \group_end:
  }

  \IfValueT { #5 }
  {
    \group_begin:
    \clist_set:Nn \l_tmpa_clist { #5 }
    \clist_map_inline:Nn \l_tmpa_clist
    {
      \@@_add_postreq:nn { #3 } { ##1 }
    }
    \group_end:
  }

  \IfValueT { #6 }
  {
    \group_begin:
    \clist_set:Nn \l_tmpa_clist { #6 }
    \clist_map_inline:Nn \l_tmpa_clist
    {
      \@@_add_coreq:nn { #3 } { ##1 }
    }
    \group_end:
  }


  \IfValueT { #7 }
  {
    \group_begin:
    \clist_set:Nn \l_tmpa_clist { #7 }
    \clist_map_inline:Nn \l_tmpa_clist
    {
      \@@_add_antireq:nn { #3 } { ##1 }
    }
    \group_end:
  }

  \IfValueT { #8 }
  {
    \group_begin:
    \clist_set:Nn \l_tmpa_clist { #8 }
    \clist_map_inline:Nn \l_tmpa_clist
    {
      \@@_load_before:nn { #3 } { ##1 }
    }
    \group_end:
  }

  \IfValueT { #9 }
  {
    \group_begin:
    \clist_set:Nn \l_tmpa_clist { #9 }
    \clist_map_inline:Nn \l_tmpa_clist
    {
      \@@_load_after:nn { #3 } { ##1 }
    }
    \group_end:
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\IncludePackages}
%   Public interface of \cs{@@_include_packages:}.
%    \begin{macrocode}
\NewDocumentCommand \IncludePackages {} { \@@_include_packages: }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\AddOptionsToPackage, \RemoveOptionsToPackage}
%   Add or remove options to a package.
%    \begin{macrocode}
\NewDocumentCommand \AddOptionsToPackage { m m }
{
  \group_begin:
  \clist_set:Nn \l_tmpa_clist { #1 }
  \clist_map_inline:Nn \l_tmpa_clist
  {
    \@@_add_option:nn { #2 } { #1 }
  }
  \group_end:
}

\NewDocumentCommand \RemoveOptionsToPackage { m m }
{
  \group_begin:
  \clist_set:Nn \l_tmpa_clist { #1 }
  \clist_map_inline:Nn \l_tmpa_clist
  {
    \@@_remove_option:nn { #2 } { #1 }
  }
  \group_end:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\AfterAll, \BeforeAll}
%   Hook some code after/before loading all packages in a list.
%    \begin{macrocode}
\NewDocumentCommand \AfterAll { m +m }
{
  \group_begin:
  \clist_set:Nn \l_tmpa_clist { #1 }
  \@@_lambda:n { #2 }

  \bool_until_do:nn { \clist_if_empty_p:N \l_tmpa_clist }
  {
    \clist_pop:NN \l_tmpa_clist \l_tmpb_tl
    \@@_lambda:x { \@@_add_post_hook:nn { \tl_use:N \l_tmpb_tl } { \tl_use:N \g_@@_last_lambda_tl } }
  }
  \group_end:

  \tl_use:c { \tl_use:N \g_@@_last_lambda_tl }
}

\NewDocumentCommand \BeforeAll { m +m }
{
  \group_begin:
  \clist_set:Nn \l_tmpa_clist { #1 }
  \@@_lambda:n { #2 }

  \bool_until_do:nn { \clist_if_empty_p:N \l_tmpa_clist }
  {
    \clist_pop:NN \l_tmpa_clist \l_tmpb_tl
    \@@_lambda:x { \@@_add_pre_hook:nn { \tl_use:N \l_tmpb_tl } { \tl_use:N \g_@@_last_lambda_tl } }
  }
  \group_end:

  \tl_use:c { \tl_use:N \g_@@_last_lambda_tl }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\AfterAny, \BeforeAny}
%   Hook some code after/before loading any one package in a list.
%    \begin{macrocode}
\NewDocumentCommand \AfterAny { m +m }
{
  \group_begin:
  \clist_set:Nn \l_@@_tmpa_clist { #1 }
  \@@_transient_lambda:n { #2 }
  \tl_set_eq:NN \l_@@_tmpa_tl \g_@@_last_lambda_tl

  \bool_until_do:nn { \clist_if_empty_p:N \l_@@_tmpa_clist }
  {
    \clist_pop:NN \l_@@_tmpa_clist \l_tmpa_tl
    \tl_gset_eq:NN \g_@@_tmpa_tl \l_tmpa_tl
    \tl_gset_eq:NN \g_@@_tmpb_tl \l_@@_tmpa_tl
    \group_end:
    \@@_add_post_hook:VV \g_@@_tmpa_tl \g_@@_tmpb_tl
    \group_begin:
  }
  \group_end:
}

\NewDocumentCommand \BeforeAny { m +m }
{
  \group_begin:
  \clist_set:Nn \l_@@_tmpa_clist { #1 }
  \@@_transient_lambda:n { #2 }
  \tl_set_eq:NN \l_@@_tmpa_tl \g_@@_last_lambda_tl

  \bool_until_do:nn { \clist_if_empty_p:N \l_@@_tmpa_clist }
  {
    \clist_pop:NN \l_@@_tmpa_clist \l_tmpa_tl
    \tl_gset_eq:NN \g_@@_tmpa_tl \l_tmpa_tl
    \tl_gset_eq:NN \g_@@_tmpb_tl \l_@@_tmpa_tl
    \group_end:
    \@@_add_pre_hook:VV \g_@@_tmpa_tl \g_@@_tmpb_tl
    \group_begin:
  }
  \group_end:
}
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \end{implementation}
%
% \Finale
